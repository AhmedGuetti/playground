#!/usr/bin/python3
# coding: utf-8

'''
LP solver using pyscipopt on a sample of bpa files
Authors:
        Ahmed GUETTI
        Imane JEMRI
        Nihad ELKADIRI
Our test:

`time ./Fsolve_bin_packing.py > solution.res  497.10s user 0.25s system 99% cpu 8:19.07 total`

this table is generated by the code 
Note: we added (gap limit) and (time limit) manualy hee for clarification perposes
| File Name                      | Nb Boites | Temps sans gestion symétries   | Temps avec gestion symétries   |
|--------------------------------|-----------|--------------------------------|--------------------------------|
| u120_00.bpa                    | ?         | (time limit)                   | (time limit)                   |
| u20_00.bpa                     | 9.0       | 0.033691                       | 1.38                           |
| inst60-non-unif_9.bpa          | 14.0      | 1.281107                       | 24.95939                       |
| u60_00.bpa                     | 27        | (time limit)                   | (time limit)                   |
| u40_00.bpa                     | 17.0      | 38.482512                      | 3.54                           |
|--------------------------------------------------------------------------------------------------------------|

Solution if u20_00
Optimale solution found :
Selected objects and there bins: 
Bin0:
	object number 0:94
	object number 2:32
	object number 13:24
Bin1:
	object number 1:69
	object number 7:78
Bin2:
	object number 8:25
	object number 9:80
	object number 19:39
Bin3:
	object number 5:84
	object number 15:60
Bin4:
	object number 10:58
	object number 16:42
	object number 18:43
Bin5:
	object number 14:98
	object number 17:43
Bin6:
	object number 6:58
	object number 12:83
Bin7:
	object number 4:70
	object number 11:66
Bin8:
	object number 3:96


Resources used: 
Khadija Hadj Salem: Université de Tours && Yann Kieffer Univ. Grenoble Alpes
    An Experimental Study on Symmetry Breaking Constraints Impact for the One Dimensional Bin-Packing Problem

'''
# import sys // this was handy when we use 
import os
import itertools
import re
import math


from pyscipopt import Model





def get_bpa_files(path):
    """
    Multiplies two numbers and returns the result.

    Args:
        path (string): a path to the folder of the test samples

    Returns:
        list[string]: list of all the files names  
    """
    pattern = ".*.md$"
    files = os.listdir(path)
    bpa_files = [x for x in files if not re.match(pattern, x)]
    return bpa_files

def open_file(path, file_name, mode):
    """
    get the contant of the files as a string and parse the result in a simple way

    Args:
        path (string): a path to the folder of the test samples
        file_name (string): the name of the file
        mode (string): in this case 'r' it open the file in the read mode 

    Returns:
        C: Capacity of the bins
        major: number of objects
        t: sizes of all the objects
        f: file desciptor returned so we can close the file
    """
    # read the file token
    C = 0
    t = []
    major = 0
    
    f = open(path + file_name,mode)
    for ligne in f:
        tokens=ligne.split()
        if(len(tokens) > 1):
            C = int(tokens[0])
            major = int(tokens[1])
        else:
            if not tokens[0].isnumeric():
                token_file_name = tokens[0] + ".bpa"
                if not file_name == token_file_name:
                    raise Exception(f"The name {file_name} in the file doesn't match to the file name {path + token_file_name}")
            else:
                t.append(int(tokens[0]))
    return C, major, t, f

def show_optimal_solution(M, x, major):
    """
    display the optimal solution

    Args:
        M (class in pyscipopt): the class containing all the method to solve a LP
        x (dict): dictionary of all the xij variable of the LP 
        major (int): number of objects

    Returns:
        None
    """
    for i,j in itertools.product(major,major): 
        value = int(M.getVal(x[i,j]))
        print(x[i,j],":",value ,sep="",end=" ")

def show_solution_human_way(M, x, t, major):
    """
    display the optimal solution in a more comprehensive way
    exemples:
    bin 0:
        object number 0   :   4
                      |       |
                    # obj  size of obj
    Args:
        M (class in pyscipopt): the class containing all the method to solve a LP
        x (dict): dictionary of all the xij variable of the LP 
        t (list): sizes of all the objects
        major (int): number of objects

    Returns:
        None
    """
    print("Selected objects and there bins: ",end="\n")
    for j in range(math.ceil(M.getObjVal())):
        print(f"Bin{j}:", end="\n")
        for i in major:
            if(M.getVal(x[i,j]) != 0):
                print(f"\tobject number {i}:{t[i]}", end="\n")    
    print()

def print_result(data):
    """
    display the resulte as table the same as the .md files
    
    Args:
        M (class in pyscipopt): the class containing all the method to solve a LP
        x (dict): dictionary of all the xij variable of the LP 
        t (list): sizes of all the objects
        major (int): number of objects

    Returns:
        None
    """
    # Print the header
    print(f"| {'File Name':<30} | {'Nb Boites':<9} | {'Temps sans gestion symétries':<30} | {'Temps avec gestion symétries':<30} |")
    print("|" + "-" * 32 + "|" + "-" * 11 + "|" + "-" * 32 + "|" + "-" * 32 + "|")

    # Print each row of data
    for row in data:
        print(f"| {row[0]:<30} | {str(row[1]):<9} | {str(row[2]):<30} | {str(row[3]):<30} |")



def main(timeout=None, max_gap=1):
    """
    The main function than won't run if we use this file in another one. 

    Args:
        timeout (int): the max time that the code will wait for each LP
        max_gap (int): the gap that we will stop the LP if we reach the solution my or may not exist 
                        we can't just wait for it 
    Returns:
        None
    """
    path = "./testing_samples/Demenageurs_Bin_packing/"
    data = []


    # Loop over all the bpa files and run the solver
    for file_name in get_bpa_files(path):
        temp = []
        temp.append(file_name)

        print(f"=========== [start] SOLVE THE {file_name} LINEAR PROGRAM [start] ===========")
        # get values from the file 
        C, major, t, f = open_file(path, file_name, 'r')
        predicted_bins = math.ceil(sum(t) / C)

        # some importatn variables
        major = range(major)
        minor = math.ceil(sum(t) / C)



        for attempt in range(2):
            # create the Model
            M = Model()

            # make a dictionary (hashmap) xij where i is the object number and j is the bin number 
            x = {}
            for i, j in itertools.product(range(n), range(predicted_bins)):
                x[i, j] = M.addVar(f"x_{i}_{j}", vtype="BINARY")

            # make a list of the bins yj where j is the bin bumber


            # y[j] indicates if bin j is used
            y = {j: M.addVar(f"y_{j}", vtype="BINARY") for j in range(predicted_bins)}

            # z[i] the maximumindex over all the items allocated to bin j
            z = {j: M.addVar(f"z_{j}", vtype="INTEGER", lb=0) for j in range(predicted_bins)}
            
            # Constraints
            for i in range(n):
                M.addCons(sum(x[i, j] for j in range(predicted_bins)) == 1, name=f"one_bin_per_item_{i}")

            for j in range(predicted_bins):
                M.addCons(sum(t[i] * x[i, j] for i in range(n)) <= C * y[j], name=f"capacity_bin_{j}")

            for i, j in itertools.product(range(n), range(predicted_bins)):
                M.addCons(x[i, j] <= y[j], name=f"bin_usage_{i}_{j}")




            if(attempt == 1):
                #  symmetry-breaking constraints
                for j in range(predicted_bins - 1):
                    M.addCons(sum(t[i] * x[i, j] for i in range(n)) >= sum(t[i] * x[i, j + 1] for i in range(n)), name=f"monotonicity_{j}")

                for j in range(predicted_bins - 1):
                    M.addCons(y[j] >= y[j + 1], name=f"order_usage_{j}")
                    
                # this make u20 run faster for some reason seen in the paper research indicated above
                #this is bad code that work on experiance 
                if(not file_name == "u20_00"):
                    for i in range(1, n):
                        for j in range(i, n): 
                            if (i, j) in x:
                                sum_terms = [x[p, j - 1] for p in range(i, n) if (p, j - 1) in x]
                                M.addCons(x[i, j] <= sum(sum_terms))


            # The objetive function
            M.setObjective(sum(y[j] for j in range(predicted_bins)), "minimize")


            # Set the timeout parameter if specified from documentation not very easy to fiind :( 
            if timeout is not None:
                M.setParam("limits/time", timeout)  # Set maximum solve time in seconds
            # well it worked whitout symetries now i don't know how to fix so let's just wait the 200s  
            # M.setParam("limits/gap", max_gap) # we chose 0.07 bc the threachold in those exemples is 0.67 for the infintes ones 
            # Run the solver
            print("-----------Solver Start--------", end="\n")
            M.optimize()
            print("-----------Solver End--------", end="\n")


            # Check if time limit was reached or gap is too high
            status = M.getStatus()
            
            # Wonderer of the web https://www.scipopt.org/doc/html/scip__general_8c_source.php
            # Check the solver's status
            status = M.getStatus()
            if status == 'timelimit':
                print(f"The solver reached the time limit for {file_name}. Moving to the next file.")
                if attempt == 0:
                    temp.append("?")
                temp.append("(time limit)")
                if attempt == 1:
                    data.append(temp)
                continue
            elif status == 'optimal':
                if attempt == 0 :
                    temp.append(M.getObjVal())
                temp.append(M.getSolvingTime())
                if attempt == 1:
                    data.append(temp)
            else:
                print("Stopped due to infeasibility or other status.")
                if attempt == 0 :
                    temp.append(" ? ")
                temp.append("(some limit)")
                if attempt == 1:
                    data.append(temp)
                continue
            # uncoment those to have a visuale solution not in a table, show the resulte 
            
            # # Show the solution all the values of variables
            # print("\nOptimale solution found :")
            # show_optimal_solution(M, x, major)
            
            # # show the selected objects and there corresponding bin
            # print("\nOptimale solution found HUMAN WAY:")
            # show_solution_human_way(M, x, t, major)

        f.close()
        print(f"=========== [finish] SOLVE THE {file_name} LINEAR PROGRAM [finish] ===========")
        temp
    data
    print_result(data)



if __name__ == '__main__':
    main(timeout=200, max_gap=1)
